## 其他设计问题

### 用户注册与登录

#### 数据库中用户密码的管理方案

用户密码在前端中加密，无论是登录还是注册，ajax请求发送的是已经用`sha1`加密过的密码，数据库存加密过后的密码，这样就能保证传输和存储安全，只有用户知道原文是什么，即使被抓包或者拖库也不会使用户面临撞库的危险。

#### 采用的加密算法

采用了**sha1**，严格来说它不是一种加密算法，因为加密算法是基于密钥的，并且有了密钥是可以解密的，**sha1**是一种不可逆的算法，被称为数字签名算法，即使截取了**sha1**处理过的文本，也无从知晓原文，但是认证起来却方便，这种算法适用于数据库中的认证信息存储。

#### 客户端Cookie的加密与时间有效期的管理方案

这里采用token而不是session-cookie机制，token同样是有有效期的

#### 登录验证码的设计与实现

可以使用**node-ccap**模块来实现，这个模块可以渲染出验证码，然后我们就可以把验证码和答案发送到前端，前端进行验证码验证。

### 购物篮的设计与实现

#### 购物篮的存储方案选择

购物篮可以通过Vuex方便地存储在客户端的localStorge里，这样下次打开可以取出

#### 购物篮中的物品与数据库中的相应物品的数据如何保持同步

可以用定时器来不断ajax更新，不过我觉得保持同步并不是很必要，因为除了库存之外，物品数据的变化不会太频繁，只要确认订单的时候更新以下就行了。

而对于库存，淘宝也没有能做到同步，可以考虑抢购场景，经常是看到还有，实际上买不到了。

#### 在不同的机器上以相同的用户身份登录，如何保持购物篮同步

将购物栏数据存入数据库，然后登录的时候同时取出就行了。

#### 提交买单请求时如何访问支付接口（如微信），支付完成后如何实现页面跳转？

首先要申请支付接口，这个是需要花钱的，所以我没有实现。

然后就只需要简单地配置一下，调用那个接口，向微信的服务器请求，然后根据返回支付结果，更新自己的数据库。

至于页面跳转，由于我做的是单页应用，并没有跳转这个东西。直接把支付弹框组件destroy掉就行了。

#### 抢购商品的应用场景下的订单问题

+ 如何将一件商品短期交给一个用户以排它方式持有？

  在数据库创建一个临时的未完成订单数据项，保存已经提交的订单信息，给库存减去相应数量，过期或者完成订单后销毁。

+ 系统如何能够保证在持有期不超过的情况下，用户买单时该商品没有被卖出？

  库存信息加锁，库存如果不大于购买量，其他用户不能买。

+ 在持有期超过的情况下，该商品可以被其它用户再次持有？

  此时未完成订单数据项销毁，给库存增加相应数量。

+ 在秒杀抢购商品的应用场景下，如何将一件商品短期交给多个用户以非排它方式持有，系统如何能够保证一件商品不会卖给两个或以上的用户？

  锁有不同机制，使用相应的锁机制可以保证这种情况的正常访问。

### REST API的调用安全性

#### 如何防止非法用户调用服务器端暴露的REST API？

使用JWT来认证用户的身份，非法用户并不能获取合法的用户的token

#### 若采用JWT，如何设计Controller、Filter，前端如何存储与管理JWT？

在后端使用一个路由拦截器，只有检查到合法的未过期的有效token才调用next()放行，其他情况返回401未认证。

代码示例如下：

```js
// app.js
/**
 * jwt验证路由
 */
let jwtAuth = require('./routes/jwtAuth');
app.all('/api/*', [ bodyParser(), jwtAuth ]);

// jwtAuth.js
module.exports = async function(req, res, next) {
    let token = (req.body && req.body.token) 
    || (req.query && req.query.token) || req.headers[ 'x-access-token' ];
    if(token) {
        try {
            let decoded = jwt.decode(token, "我是密钥");
            if(decoded.exp <= Date.now()) {
               // 过期 返回401 
            }
            // 访问数据库取出用户信息
            let theUser = await User.fetchById(decoded.iss);
            if(theUser == null) {
                // 无效 返回401
            }
          	//token有效 放行
            next();
        } catch(err) {
            // 数据库访问失败 返回500
        }
    } else {
        // 无token 返回401
    }
};


```

#### 会话有效期超过之后，在无需用户手工登录的需求下如何自动续期？安全性有何弱点？

我并不认为自动续期能带来什么好处，反而容易产生如**csrf**这样的安全隐患，用户手工登录一下并不会多麻烦，而且与其自动续期，还不如设置不过期。

